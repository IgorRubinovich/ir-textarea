<dom-module id="ir-textarea-range-marker">
	<style>
		#marker {
			background : violet;
			padding-left : 3px;
			padding-right : 3px;
			outline : none;
		}
	</style>
	<template><span id="marker"
				contenteditable
				on-focus="observerConnect"
				on-blur="observerDisconnect"
				
				></span></template>	
</dom-module>
<script>
	(function() {
		var utils = ir.textarea.utils;

		Polymer({
			is : "ir-textarea-range-marker",
			properties : {
				// tag outline of realContainer
				tagOutline : {
					type : String,
					notify : true
				},
				// actual container
				container : {
					type : Object,
					notify : true
				},				
				// actual offset
				offset : {
					type : Number,
					notify : true
				},
				// real range's container on side identified by bindToRange
				realContainer : {
					type : Object,
					notify : true
				},
				// real range's offset on side identified by bindToRange
				realOffset : {
					type : Number,
					notify : true
				},
				// real range's container element on side identified by bindToRange
				containerElement : {
					type : Object,
					notify : true
				},
				// real range's offset in container element on side identified by bindToRange
				containerElementOffset : {
					type : Number,
					notify : true
				},
				editor : {
					type : Object
				},
				bindToRange : {
					type : String,
					value : 'start'
				},
				visible : {
					type : Boolean,
					notify : true
				},
			},
			
			ready : function() {
				this.isCaret = this.$.marker.isCaret = true;
				this.hostMarker = this.$.marker.hostMarker = this;

				this.mo = new MutationObserver(this.mutationHandler.bind(this)),
				this.moconfig = {
						childList : true,
						subtree : true,
						characterData : true,
						characterDataOldValue : true
						//attributes : true
					}

				this.originalInnerHTML = '';
				
			},
			
			observerConnect : function() {
				this.mo.observe(this.containerElement, this.moconfig);
			},
			
			observerDisconnect : function() {
				this.mo.disconnect();
			},
			
			mutationHandler : function() {				
				var c, m = this.$.marker;
				
				if(!m.childNodes.length)
					return;

				if(c = utils.singleChildNode(m))
					if(c.nodeType == 3 && !c.textContent.length)
						return;

				this.observerDisconnect();				

				while(m.childNodes.length)
					parentNode.insertBefore(m.firstChild, this);
				
				this.observerConnect();

				this.update();
			},
			
			show : function() {
				var r = utils.getSelectionRange(), c, o;
				
				if(!r)
					return;
					
				if(this.bindToRange != 'start' && r.collapsed)
					return this.hide();

				this.visible = true;

				c = this.containerElement;
				o = this.containerElementOffset;
				if(c.childNodes[o])
				{
					c.insertBefore(this, c.childNodes[o]);

					if(this != parentNode.lastChild && this.realContainer.nodeType != 3)
						this.set('realOffset', this.realOffset + 1);					
				}
				else
					c.appendChild(this);
					
					
				/*if(this.container == this.editor)
				{
					if(!this.container.childNodes[this.offset])
						this.container.appendChild(this);
					else
						this.realContainer.insertBefore(this, this.realContainer.childNodes[this.realOffset]);
				}
				else
				//if(this.container.childNodes[this.offset])
					this.realContainer.parentNode.insertBefore(this, this.realContainer);*/
					
				if(this.bindToRange == 'end')
					this.$.marker.style.background = 'lightgreen';
				
				this.pullRange();
			},
			
			hide : function() {
				var pn;
				
				this.visible = false;

				if(!this.parentNode)
					return;

				if(this != this.parentNode.lastChild && this.realContainer.nodeType != 3)
				{
					console.log('subtracting this.realOffset for ', this.realOffset, this.crealContainer);
					this.realOffset--;
				}

					
				pn = this.parentNode;
				pn.removeChild(this);
				
				this.setAt(this.realContainer, this.realOffset, true);
					
				//this.updateFromCurrentRange();
				//this.update();
			},
			
			update : function() {
				var tn;
				
				this.updateFromCurrentRange();
				this.adjust();
			},

			adjust : function() {			
				var hide, n, p, tcea, editable, tc, offsetChild, c, o, ce, ceo, rc, ro;
				
				r = utils.getSelectionRange();

				if(!r || (this.bindToRange == 'end' && r.collapsed))
					return;
				
				//if(!this.visible && this.realContainer && this.realContainer.nodeType == 3)
				//	return;

				ce = this.containerElement;
				ceo = this.containerElementOffset;
				
				if(!ce)
					return;
				
				if(this.visible)
				{
					if(this.realContainer && this.realContainer.nodeType == 3 && !/^\s*$/.test(this.realContainer.textContent))
						return this.hide();

					n = ce.childNodes[ceo - 1];
					c = ce.childNodes[ceo + 1];
					p = ce.childNodes[ceo + 2];

					if(c && c.nodeType == 3)
						return;
					if(p && p.nodeType == 3 && !/^\s*$/.test(p.textContent))
					{
						this.hide();
						this.setAt(p, p.textContent.length, true);
					}
					if(n && n.nodeType == 3 && !/^\s*$/.test(n.textContent))
					{
						this.hide();
						this.setAt(n, 0, true);
					}
				}
				else
				{
					c = ce.childNodes[ceo];

					rc = this.realContainer;
					if(rc == c && !rc.is && rc.firstChild && rc.firstChild.nodeType == 3)
						rc = c.firstChild
					
					if(	!c || 
						c.is || 
						(c.nodeType != 3 && !utils.canHaveChildren(c)) || // not container
						(c.previousSibling && c.previousSibling.is && rc != c.firstChild) || 	  // after CE
						(c.nodeType == 3 && /^\s*$/.test(c.textContent))) // empty text node
						this.show();
				}
				
				//if(this.visible)
			},

			pushRange : function(ev) {
				var tpce, cetnstart, cetnend, pd, nn, n, c, p;

				if(this.bindToRange == 'end')
					this.hide();
				
				ce = this.containerElement;
				ceo = this.containerElementOffset;
				
				if(!ce)
					return;
				
				this.hide();

				// inside custom element with c set to contenteditable
				tpce = utils.getTopCustomElementAncestor(c, this.editor);
				if(tpce && tpce != c)
				{
					cetnstart = this.realOffset == 0; // && this.realContainer.nodeType == 3;
					cetnend = this.realOffset == this.realContainer.length; // && this.realContainer.nodeType == 3;

					if((cetnstart && ev.keyCode == 8) || (cetnend && ev.keyCode == 46)) // backspace/del
						pd = true;
					else
					if(cetnstart && ev.keyCode == 37)
						pd = utils.setCaretAt(tpce, 0);
					else
					if(cetnend && ev.keyCode == 39)
						pd = utils.setCaretAt(tpce.parentNode, utils.getChildPositionInParent(tpce) + 1);
						
					if(pd)
						ev.preventDefault();
						
					return;
				}
				
				// other cases
				if(ev.keyCode == 37 && this.offset > 0) // left
				{
					this.hide();
					pd = utils.setCaretAt(this.container, this.offset - 1);
				}
				else
				if(ev.keyCode == 39) // right
				{
					// this.hide();

					nn = this.nextPosition(this.realContainer, this.realOffset);
					//console.log(`right: ${this.bindToRange} ${ev.type} from ${this.realContainer.textContent}, ${this.realOffset} to ${nn.container.textContent}, ${nn.offset}`);
					
					if(nn)
						pd = this.setAt(nn.container, nn.offset, true);
					
					//this.update();						
				}
				else
				if(ev.keyCode == 36) // home
				{
					this.hide();
					pd = utils.setCaretAt(this.containerElement, 0);
				}
				else
				if(ev.keyCode == 35) // end
				{
					this.hide();
					pd = utils.setCaretAt(this.containerElement, this.containerElement.childNodes.length);
				}
				
				if(pd)
					ev.preventDefault();

				//utils.setCaretAt(this.realContainer, this.realOffset);

			},
			
			nextPosition : function(container, offset, fromNode) {
				var c = container, o = offset, ce, indexOf = utils.getChildPositionInParent, isWhitespace, tcea;

				if(!c)
					return;
					
				if(fromNode)
				{
					if(c.childNodes[o] == fromNode)
						return this.nextPosition(c, o + 1, fromNode);
					else
					if(c != this.editor && fromNode && utils.isDescendantOf(fromNode, container))
					{					
						if(tcea = utils.getTopCustomElementAncestor(c, this.editor))
							c = tcea;

						return this.nextPosition(parentNode(c), indexOf(c), c);
					}
				}
				
				if(!c)
					return null;
				
				if(c.isCaret)
					this.nextPosition(c.hostMarker.realContainer, c.hostMarker.realOffset, true);
				
				// marker at end of editor - no change
				if(c == this.editor)
					if(o >= this.editor.childNodes.length)
						return { container : c, offset : o };
					else
						return this.nextPosition(c.childNodes[o], 0, fromNode);
				
				
				if(c.nodeType != 3 && o >= c.childNodes.length && utils.canHaveChildren(c))
					return this.nextPosition(parentNode(c), indexOf(c) + 1, fromNode);
				
				// text node
					// marker is in text node
					isWhitespace = /^\s*$/.test(c.textContent);
					if(c.nodeType == 3)
					{
						//if(c.textContent && isWhitespace)
						//	return recursive ? { container : c, offset : o } : this.nextPosition(c.parentNode, indexOf(c) + 1, true);
						if(isWhitespace && fromNode && fromNode.is) //!c.textContent)
							return fromNode ? { container : c, offset : o } : null;
						// start/mid
						if(o < c.textContent.length)
							return fromNode ?  { container : c, offset : 0 } : null;
						// end
						else
							return this.nextPosition(parentNode(c), indexOf(c) + 1, c);
					}

					// marker is at (not in) text node
					if((!fromNode || !fromNode.is) && !c.is && c.childNodes && c.childNodes[o] && c.childNodes[o].nodeType == 3)
					{
						if(!c.childNodes[o].textContent.length)
							return this.nextPosition(c, o+1, c);
						else
							return { container : c.childNodes[o], offset : 0 }
					}

				// element
					// custom
					if(c.is)
						if(fromNode)
							return { container : parentNode(c), offset : indexOf(c) }
						else
						// has editable light dom children
						if(ce = Polymer.dom(c).querySelector('[contenteditable]'))
							return this.nextPosition(ce, 0, fromNode);
						// doesn't have any
						else
							return this.nextPosition(parentNode(c), indexOf(c) + 1, c)

							
					if(fromNode && fromNode.is && c != this.editor)
						return { container : parentNode(c), offset : indexOf(c) };
					
					// container
					if(c.firstChild)
						return this.nextPosition(c.firstChild, 0, c);
					else
					if(fromNode && utils.canHaveChildren(c))
						return { container : c, offset : 0 }
					else
						return this.nextPosition(parentNode(c), indexOf(c) + 1, c);
						
					// non-container
					if(fromNode)
						return { container : parentNode(c), offset : indexOf(c) }
					else
						return this.nextPosition(parentNode(c), indexOf(c) + 1, c);
					
			},
			previousPosition : function(container, offset, fromNode) {
				var c = container, o = offset, ce, indexOf = utils.getChildPositionInParent, isWhitespace;
				
				if(!c)
					return null;
				
				if(c.isCaret)
					this.previousPosition(c.hostMarker.realContainer, c.hostMarker.realOffset, true);
				
				// marker at end of editor - no change
				if(c == this.editor)
					if(o >= this.editor.childNodes.length)
						return { container : c, offset : o };
					else
						return this.nextPosition(c.childNodes[o], 0, fromNode);
				
				
				if(c.nodeType != 3 && o >= c.childNodes.length && utils.canHaveChildren(c))
					return this.nextPosition(c.parentNode, indexOf(c) + 1, true);
				
				// text node
					// marker is in text node
					isWhitespace = /^\s*$/.test(c.textContent);
					if(c.nodeType == 3)
					{
						//if(c.textContent && isWhitespace)
						//	return recursive ? { container : c, offset : o } : this.nextPosition(c.parentNode, indexOf(c) + 1, true);
						if(isWhitespace && fromNode && fromNode.is) //!c.textContent)
							return { container : c, offset : o };
						// start/mid
						if(o < c.textContent.length) 
							return { container : c, offset : fromNode ? 0 : o + 1 }
						// end
						else
							return this.nextPosition(c.parentNode, indexOf(c) + 1, c);
					}

					// marker is at (not in) text node
					if(fromNode && !fromNode.is && !c.is && c.childNodes && c.childNodes[o] && c.childNodes[o].nodeType == 3)
						return { container : c.childNodes[o], offset : 0 }

				// element
					// custom
					if(c.is)
						if(fromNode)
							return { container : c.parentNode, offset : indexOf(c) }
						else
						// has editable light dom children
						if(ce = Polymer.dom(c).querySelector('[contenteditable]'))
							return this.nextPosition(ce, 0, true);
						// doesn't have any
						else
							return this.nextPosition(c.parentNode, indexOf(c) + 1, c)

							
					if(fromNode && fromNode.is)
						return { container : c, offset : o };
					
					// container
					if(c.firstChild)
						return this.nextPosition(c.firstChild, 0, c);
					else
					if(fromNode && utils.canHaveChildren(c))
						return { container : c, offset : 0 }
					else
						return this.nextPosition(c.parentNode, indexOf(c) + 1, c);
						
					// non-container
					if(fromNode)
						return { container : c.parentNode, offset : indexOf(c) }
					else
						return this.nextPosition(c.parentNode, indexOf(c) + 1, c);
					
			},
			pullRange : function() {
				var r = utils.getSelectionRange() || {}, tn;
				
				if(!this.$.marker.firstChild)
				{
					tn = this.$.marker.appendChild(document.createTextNode(''));
					tn.isCaret = true;
					tn.hostMarker = this.hostMarker;
				}

				if(r.collapsed)
					return utils.setCaretAt(tn, 0);

				if(this.bindToRange == 'start')
					return utils.setCaretAt(tn, 0, r.ec, r.eo);

				if(this.bindToRange == 'end')
					return utils.setCaretAt(r.sc, r.so, tn, 0);
			},
			
			updateFromCurrentRange : function() {
				var r = utils.getSelectionRange(), c, o, chm;
				
				if(!r)
					return;
				
				this.setAt(r[this.bindToRange + "Container"], r[this.bindToRange + "Offset"]);
			},

			setAt : function(container, offset, setRange) {
				var chm, r, realOffset, oc, oo;

				//if(!container.parentNode)
				//	return;

				chm	= container && container.hostMarker;
				
				if(chm && chm != this)
				{
					this.set('container', chm.container);
					this.set('offset', chm.offset);
					this.set('realContainer', chm.realContainer);
					this.set('realOffset', chm.realOffset);
					this.set('containerElement', chm.containerElement);
					this.set('containerElementOffset', chm.containerElementOffset);
				}
				else
				if(!chm)
				{
					/*if(container)
					{
						if(container.parentNode)
							container.parentNode.normalize();
						else
							container.normalize();
					}*/					
				
					this.set('container', container);
					this.set('offset', offset);
					this.set('realContainer', container);
					this.set('realOffset', offset);
					this.set('containerElement', !container || container == this.editor ? container : container.parentNode);
					this.set('containerElementOffset', !container || container == this.editor ? offset : utils.getChildPositionInParent(container, true));
				}

				//if(this.realContainer.isCaret)
				//	console.log("this.realContainer.isCaret!")
				this.set('tagOutline', utils.tagOutline(this.containerElement));

				if(setRange)
				{
					r = utils.getSelectionRange() || {};

					if(r.collapsed)
						return utils.setCaretAt(container, offset);
					
					if(this.bindToRange == 'start')
						return utils.setCaretAt(container, offset, r.ec, r.eo);

					return utils.setCaretAt(r.sc, r.so, container, offset);
				}

				// console.log(this.bindToRange + " " + this.tagOutline + " " + this.offset)
			},			
		})
		
			
		function parentNode(node) {
			if(Polymer.dom(node).parentNode != node.parentNode && !utils.isInLightDom(node, top))
				return Polymer.dom(node).parentNode;
			else
				return node.parentNode;
		}
	})();
</script>
			
