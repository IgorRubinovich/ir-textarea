<dom-module id="ir-textarea-range-marker">
	<style>
		#marker {
			background : violet;
			padding-left : 3px;
			padding-right : 3px;
			outline : none;
		}
	</style>
	<template><span id="marker"
				contenteditable
				on-focus="observerConnect"
				on-blur="observerDisconnect"
				
				></span></template>	
</dom-module>
<script>
	(function() {
		var utils = ir.textarea.utils;	

		Polymer({
			is : "ir-textarea-range-marker",
			properties : {
				// tag outline of realContainer
				editor : {
					type : Object,
					notify : true,
					observer : "editorChanged"
				},
				bindToRange : {
					type : String,
					value : 'start'
				},
				visible : {
					type : Boolean,
					notify : true
				},
				container : {
					type : Object,
					notify : true
				},
				offset : {
					type : Number,
					notify : true
				},
				realContainer : {
					type : Object,
					notify : true
				},
				realOffset : {
					type : Number,
					notify : true
				},
				tagOutline : {
					type : String,
					notify : true
				}
			},
			
			ready : function() {
				this.isCaret = this.$.marker.isCaret = true;
				this.hostMarker = this.$.marker.hostMarker = this;
	
				this.isListening = true;

				this.mo = new MutationObserver(this.mutationHandler.bind(this)),
				this.moconfig = {
						childList : true,
						subtree : true,
						characterData : true,
						characterDataOldValue : true
						//attributes : true
					}

				if(this.bindToRange == 'end')
					this.$.marker.style.background = 'lightgreen';

				this._activeHandlers = {};
					
				this.originalInnerHTML = '';			
			},
			
			editorChanged : function(n, o) {
				var caretNavOpts = { 
										log : false, 
										caretSpan : this,
										caretSpanShow : this.show.bind(this),
										caretSpanHide : this.hide.bind(this)
									};

				this.caretNavigator = new ir.textarea.CaretNavigator(this.editor, caretNavOpts)
				
				if(o)
					Object.keys(this._activeHandlers)
						.forEach(function(k) {
							this.editor.removeEventListener(k, this._activeHandlers[k])
						});
				
				this.setAt(this.editor, 0);
				
				//is.editor.addEventListener('keydown', this._activeHandlers.keydown = this.keyDownHandler.bind(this));
				//this.editor.addEventListener('keyup', this._activeHandlers.keyup = this.keyUpHandler.bind(this));
				this.editor.addEventListener('mousedown', this._activeHandlers.mousedown = this.mouseHandler.bind(this));
				this.editor.addEventListener('mouseup', this._activeHandlers.mouseup = this.mouseHandler.bind(this));
				//this.editor.addEventListener('mouseup', this._activeHandlers.mouseup = this.update.bind(this));
			},
			
			observerConnect : function() {
				if(this.containerElement)
					this.mo.observe(this.containerElement, this.moconfig);
			},
			
			observerDisconnect : function() {
				this.mo.disconnect();
			},
			
			go : function(dir, crossingPoint) {
				var pos;
				
				this.hide();
				pos = this.caretNavigator.goFrom({ container : this.realContainer, offset : this.realOffset}, dir, this.bindToRange);
		
				this.setAt(pos.container, pos.offset);
			},
			
			goAt : function(pos, bindToRange) {
				this.hide();
				pos = this.caretNavigator.goAt({ container : pos.container, offset : pos.offset}, this.bindToRange);
				this.setAt(pos.container, pos.offset);
			},
			
			hasContent : function() {
				return !(this.firstChild.textContent == '\u200B' && this.childNodes.length == 1);
			},
			
			mutationHandler : function() {				
				var c, m = this.$.marker, lastInserted;
				
				if(!this.hasContent())
					return;

				if(c = utils.singleChildNode(m))
					if(c.nodeType == 3 && !c.textContent.length)
						return;

				this.observerDisconnect();				

				while(m.childNodes.length)
					lastInserted = this.parentNode.insertBefore(m.firstChild, this);
				
				if(lastInserted && lastInserted.nodeType == 3)
					this.setAt(lastInserted, lastInserted.textContent.length);

				this.hide()
				
				this.observerConnect();

				this.update();
			},

			show : function(container, offset, rangeSide) {
				var r = utils.getSelectionRange(), c, o, doPull, skipShowAndPull, 
					isEnd = this.bindToRange == 'end', isAfterCaret;

				if(/start|end/.test(rangeSide) && rangeSide != this.bindToRange)
					return;
				
				if(!container && !r)
					return;
					
				if(this.bindToRange != 'start' && r && r.collapsed)
					return this.hide();

				if(container)
				{
					c = container
					o = offset;
				}
				else
				{
					c = this.container;
					o = this.offset;
				}
				
				//if(isAfterCaret && end)
				
				if(c == this.editor && o == c.childNodes.length)
				{
					isAfterCaret = o > 0 && c.childNodes[o-1] && c.childNodes[o-1].isCaret;
					if(!(isEnd && isAfterCaret))
						doPull = c.parentNode.appendChild(this);
				}
				else
				{
					if(c == this.editor)
					{
						c = c.childNodes[o]
						o = 0;
					}
					isAfterCaret = c.previousSibling && c.previousSibling.isCaret;
					
					if(!(isEnd && isAfterCaret))
						doPull = c.parentNode.insertBefore(this, c);
				}

				if(doPull)
				{
					this.pullRange();
					this.visible = true;
				}
				
				this.updateFromCurrentRange();
			},

			hide : function() {
				var pn;
				
				this.visible = false;

				if(!this.parentNode)
					return;

				if(this.realContainer == this.editor && this.realOffset < this.editor.childNodes.length)
				{
					console.log('subtracting this.realOffset for ', this.realOffset, this.crealContainer);
					this.realOffset--;
				}

					
				pn = this.parentNode;
				pn.removeChild(this);
				
				//this.setAt(this.realContainer, this.realOffset, true);
					
				//this.updateFromCurrentRange();
				//this.update();
			},
			
			startListening : function()  {
				this.isListening = true;
				console.log("LISTENING: " + this.bindToRange)
			},
			
			stopListening : function()  {
				this.isListening = false;
				//console.log(this.bindToRange + " marker stopped listening")
			},
			
			mouseHandler : function (ev) {
				var c, o, cp, updateWhich, r;
				
				//if(!this.isListening)
				//	return;

				//if(ev.target.nodeType == 3)
				//	return;
					
				cp = utils.caretPositionFromPoint(ev.clientX, ev.clientY);

				o = cp.offset;
				c = cp.node;
				
				if(!c)
					return;
				
				if(!utils.isInLightDom(c, this.editor))
				{
					c = utils.getTopCustomElementAncestor(c, this.editor);
					o = 0;
				}
				
				if(ev.type == "mousedown" && !ev.shiftKey)
				{
					r = utils.getSelectionRange();

					if(this.bindToRange == 'start')
						this.caretNavigator.go({ container : c, offset : o}, "both");
					else
					{
						utils.setCaretAt(r.startContainer, r.startOffset);
						this.updateFromCurrentRange();
					}
				}
				else
				{
					var r = utils.getSelectionRange() || {};
					
					this.updateFromCurrentRange();
					
					if(!r.collapsed)
						this.caretNavigator.goAt({ container : this.container, offset : this.offset }, this.bindToRange);
				};
					// this.updateFromCurrentRange()
				//console.table([{ ev : ev.type, rangeSide : this.bindToRange, container : c, offset : o, 
				console.log();

				return;
				if(ev.type == "mousedown")
					this.caretNavigator.go({ container : c, offset : o}, this.bindToRange);
				else
				if(ev.type == "mouseup")
				{
					
					updateWhich = utils.caretposcmp({ container : this.container, offset : this.offset }, { container : c, offset : o });
					if(updateWhich < 0 && this.bindToRange == 'start')
						this.caretNavigator.goAt({ container : c, offset : o }, this.bindToRange);
					else
					if(updateWhich > 0 && this.bindToRange == 'end')
						this.caretNavigator.goAt({ container : c, offset : o }, this.bindToRange);
				}

				this.preventNextDefault = true;
				
				this.update();
			},
			
			update : function() {
				var tn, pos;
				
				this.updateFromCurrentRange();
				
				//if(this.isListening)
				this.adjust();
			},

			adjust : function() {
				var pos;
				
				if(this.container)
					this.caretNavigator.go({container : this.container, offset : this.offset}, this.bindToRange);
			},

			pushRange : function(ev) {
				var tpce, cetnstart, cetnend, pd, nn, n, c, p;

				if(this.bindToRange == 'end')
					this.hide();
				
				ce = this.containerElement;
				ceo = this.containerElementOffset;
				
				if(!ce)
					return;
				
				this.hide();

				// inside custom element with c set to contenteditable
				tpce = utils.getTopCustomElementAncestor(c, this.editor);
				if(tpce && tpce != c)
				{
					cetnstart = this.realOffset == 0; // && this.realContainer.nodeType == 3;
					cetnend = this.realOffset == this.realContainer.length; // && this.realContainer.nodeType == 3;

					if((cetnstart && ev.keyCode == 8) || (cetnend && ev.keyCode == 46)) // backspace/del
						pd = true;
					else
					if(cetnstart && ev.keyCode == 37)
						pd = utils.setCaretAt(tpce, 0);
					else
					if(cetnend && ev.keyCode == 39)
						pd = utils.setCaretAt(tpce.parentNode, utils.getChildPositionInParent(tpce) + 1);
						
					if(pd)
						ev.preventDefault();
						
					return;
				}
				
				// other cases
				if(ev.keyCode == 37 && this.offset > 0) // left
				{
					this.hide();
					pd = utils.setCaretAt(this.container, this.offset - 1);
				}
				else
				if(ev.keyCode == 39) // right
				{
					nn = this.nextPosition(this.realContainer, this.realOffset);
					
					if(nn)
						pd = this.setAt(nn.container, nn.offset, true);
				}
				else
				if(ev.keyCode == 36) // home
				{
					this.hide();
					pd = utils.setCaretAt(this.containerElement, 0);
				}
				else
				if(ev.keyCode == 35) // end
				{
					this.hide();
					pd = utils.setCaretAt(this.containerElement, this.containerElement.childNodes.length);
				}
				
				if(pd)
					ev.preventDefault();

				//utils.setCaretAt(this.realContainer, this.realOffset);

			},
			
			nextPosition : function(container, offset, fromNode) {
				this.caretNavigator.go("forward");
			},

			previousPosition : function(container, offset, fromNode) {
				this.caretNavigator.go("backward");
			},

			pullRange : function() {
				var r = utils.getSelectionRange() || {}, tn;

				tn = this.$.marker.firstChild;
				if(!tn)
				{
					tn = this.$.marker.appendChild(document.createTextNode('\u200B'));
					tn.isCaret = true;
					tn.hostMarker = this.hostMarker;
				}

				this.container = tn;
				this.offset = 0;
				
				if(r.collapsed)
					return utils.setCaretAt(tn, 0);

				if(this.bindToRange == 'start')
					return utils.setCaretAt(tn, 0, r.ec, r.eo);

				if(this.bindToRange == 'end')
					return utils.setCaretAt(r.sc, r.so, tn, 0);
			},
			
			updateFromCurrentRange : function() {
				var r = utils.getSelectionRange(), c, o, chm;
				
				if(!r)
					return;
				
				c = r[this.bindToRange + "Container"];
				o = r[this.bindToRange + "Offset"];
				
				if(c.isCaret && c.hostMarker == this)
					return;

				if(this.realContainer && (c == this.realContainer && o == this.realOffset))
					return
				
				this.setAt(c, o);
			},

			setAt : function(container, offset, setRange) {
				var chm, r, realOffset, oc, oo, 
					fields = "container,offset,realContainer,realOffset,containerElement,containerElementOffset";

				// marker lands on another marker
				chm	= container && container.hostMarker;
				// end marker lands on realContainer of start marker
				if(!chm && container.nodeType != 3 && this.bindToRange == 'end')
				{
					if(container == this.editor && offset < this.editor.childNodes.length)
						container = this.editor.childNodes[offset];
					
					chm = container.hostMarker
					if(!chm)
						chm = container.previousSibling && (container.previousSibling != this) && container.previousSibling.hostMarker;
				}
				
				// in both above cases just make markers identical
				if(chm && chm != this)
				{					fields.split(",").forEach(function(f) { this.set(f, chm[f]); }.bind(this))
					fields.split(",").forEach(function(f) { this.set(f, chm[f]); }.bind(this))
					if(this.bindToRange == 'start')
					{
						this.container = this.$.marker.firstChild;
						this.offset = 0;
					}
				}
				else
				if(chm)
					return
				else
				if(!chm)
				{
					containerElement = !container || container == this.editor ? container : container.parentNode;
					containerOffset = !container || container == this.editor ? offset : utils.getChildPositionInParent(container, true);
					
					if(containerElement)
						containerElement.normalize();
					
					this.set('container', this.visible ?  this.$.marker.firstChild : container);
					this.set('offset', this.visible ? 0 : offset);

					this.set('realContainer', container);
					this.set('realOffset', offset);
					this.set('containerElement', containerElement);
					this.set('containerElementOffset', containerOffset);
				}

				
				if(this.container && this.container == this.editor)
					this.set('tagOutline', 'editor')
				else
				if(this.container)
					this.set('tagOutline', utils.tagOutline(this.container.nodeType == 3 ? this.container.parentNode : this.container));

				if(setRange)
				{
					r = utils.getSelectionRange() || {};

					if(r.collapsed)
						return utils.setCaretAt(container, offset);
					
					if(this.bindToRange == 'start')
						return utils.setCaretAt(container, offset, r.ec, r.eo);

					return utils.setCaretAt(r.sc, r.so, container, offset);
				}
			},			
		})
		
			
		function parentNode(node) {
			if(Polymer.dom(node).parentNode != node.parentNode && !utils.isInLightDom(node, top))
				return Polymer.dom(node).parentNode;
			else
				return node.parentNode;
		}
	})();
</script>
			
