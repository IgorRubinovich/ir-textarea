<dom-module id="ir-textarea-range">
	<template>
		<h1>caret debug</h1>
		collapsed: {{ collapsed }}
		<table on-click="log" style="marin-top : -400px" border=1 width="100%">
			<tr>
				<td></td>
				<td>tagOutline</td>
				<td>container</td>
				<td>offset</td>
				<td>visible</td>
			</tr>
			<tr>
				<td>Start</td>
				<td>{{ startTagOutline }}</td>
				<td>{{ startContainer }}</td>
				<td>{{ startOffset }}</td>
				<td>{{ startIsVisible }}</td>
			</tr>
			<tr>
				<td>End</td>
				<td>{{ endTagOutline }}</td>
				<td>{{ endContainer }}</td>
				<td>{{ endOffset }}</td>
				<td>{{ endIsVisible }}</td>
			</tr>
		</table>

		<ir-textarea-range-marker 
			id="start" 
			bind-to-range="start" 
			tag-outline="{{ startTagOutline }}" 
			real-container="{{ startContainer }}" 
			real-offset="{{ startOffset }}"
			visible="{{ startIsVisible }}"
		>
		</ir-textarea-range>
		<ir-textarea-range-marker 
			id="end" 
			bind-to-range="end" 
			tag-outline="{{ endTagOutline }}" 
			real-container="{{ endContainer }}" 
			real-offset="{{ endOffset }}"
			visible="{{ endIsVisible }}"
		>
		</ir-textarea-range>
	</template>
</dom-module>

<script>
	(function() {
		var utils = ir.textarea.utils,
			SYMBOLS = ir.textarea.CaretRulesets.Symbols,
			Rulesets = ir.textarea.CaretRulesets,
			paste = ir.textarea.paste;
		
		Polymer({
			is : "ir-textarea-range",
			properties : {
				editor : {
					type : Object,
					observer : "editorChanged"
				},
				collapsed : {
					type : String,
					notify : true,
					computed : "_collapsed(startContainer,startOffset,endContainer,endOffset)" 
				},
				startPosition : {
					type : Object,
					notify : true,
					computed : "_startPosition(startContainer,startOffset)" 
				},
				endPosition : {
					type : Object,
					notify : true,
					computed : "_endPosition(endContainer,endOffset)" 
				},
				startContainer : { type : Object, notify : true },
				startOffset : { type : Number, notify : true },
				endContainer : { type : Object, notify : true },
				endOffset : { type : Number, notify : true }
			},
			
			log : function(e) {
				console.log(this.startContainer, this.endContainer)
			},
			
			_startPosition : function(startContainer, startOffset) {
				return { container : startContainer, offset : startOffset }
			},
			_endPosition : function(endContainer, endOffset) {
				return { container : endContainer, offset : endOffset }
			},
			
			_collapsed : function(startContainer,startoffset,endContainer,endOffset)
			{
				//this.set("collapsed", );
				//console.log(this.startContainer == this.endContainer && this.startOffset == this.endOffset)
				return this.startContainer == this.endContainer && this.startOffset == this.endOffset
			},
			
			collapse : function(toEnd) {
				var from, to;
				from = toEnd ? 'end' : 'start';
				to = toEnd ? 'start' : 'end';

				from = this.$[from];
				to = this.$[to];
				
				to.goAt({ container : from.realContainer, offset : from.realOffset });
				if(from == this.$.end)
					this.$.end.goAt({ container : from.realContainer, offset : from.realOffset });
				
				this.updateNativeRange();
			},
			
			editorChanged : function() {
				var caretNavOpts;
				
				this.$.start.editor = this.editor;
				this.$.end.editor = this.editor;

				this.editor.addEventListener('keydown', this.keyDownHandler.bind(this));
				this.editor.addEventListener('keyup', this.keyUpHandler.bind(this));
				
				this.editor.addEventListener('mousedown', this.mouseDownHandler.bind(this));
				this.editor.addEventListener('mouseup', this.mouseUpHandler.bind(this));


				caretNavOpts = { 
						log : false, 
						caretSpan : this,
						caretSpanShow : false,
						caretSpanHide : false
					};

				this.caretNavigator = new ir.textarea.CaretNavigator(this.editor, caretNavOpts);
			},
			
			mouseUpHandler : function(e) {
				var hm, cp = utils.caretPositionFromPoint(e.clientX, e.clientY), startPos, endPos, reverseFlow, 
					lcpos = this.lastClickPos;

				this.lastClickPos = null;
					
				if(hm = cp.container.hostMarker || (utils.isContainer(cp.container) && (hm = cp.container.childNodes[cp.offset].hostMarker))) 
				{						
					cp.container = hm.caretSpace;
					cp.offset = 0;
					
					this.setAt(cp);
				}
				else
				if(e.shiftKey || lcpos)
				{
					if(lcpos)
					{
						startPos = this.$.start;
						endPos = cp;
					}
					else
					{
						startPos = { container : this.startContainer, offset : this.startOffset };
						endPos = cp;
					}
					
					reverseFlow = utils.caretposcmp(startPos, endPos, this.editor) > 0;
					
					this.lastActive = reverseFlow ? 'end' : 'start'; 
					
					this.setAt(startPos, endPos);
					
					this.justUpdated = true;
				}
				
				e.preventDefault();
			},
			
			mouseDownHandler : function(e) {
				var cp = utils.caretPositionFromPoint(e.clientX, e.clientY);
				//if(!e.shiftKey)
				
				if(!this.lastClickPos)
					this.lastClickPos = { container : cp.container, offset : cp.offset }
				
				if(!e.shiftKey)
					this.setAt(cp);
			},
			
			setAt : function(startContainer, startOffset, endContainer, endOffset) {
				//if(startContaienr == endContainer && startOffset == endOffset)
				var startPos, endPos, t, reverseFlow;
				
				if(startContainer.container)
				{
					startPos = startContainer;
					endPos = startOffset;
				}
				else
				{
					startPos = { container : startContainer, offset : startOffset };
					endPos = { container : endContainer, offset : endOffset };
				}
					
				if(!endPos || !endPos.container)
					endPos = startPos;
				else
				// swap if reverse flow order
				if(utils.caretposcmp(startPos, endPos, this.editor) > 0)
				{
					t = startPos;
					if(t.hostMarker)
						t = { container : t.hostMarker.realContainer, offset : t.hostMarker.realOffset };

					startPos = endPos;
					endPos = t;
				}
								
				if(!(this.$.start.visible && this.$.start.isAt(startPos)))
					this.$.start.goAt(startPos);
				
				if(startPos == endPos)
					this.$.end.setAt(this.$.start)
				else
				if(!(this.$.end.visible && this.$.end.isAt(endPos)))
					this.$.end.goAt(endPos)
		
				this.updateNativeRange()
				//if(this.collapsed)
				//	this.$.end.hide();
			},
			
			setStartAt : function(c, o) {
				this.$.start.goAt(c, o);
			},
			setEndAt : function(c, o) {
				this.$.end.goAt(c, o);
			},
			update : function() {
				this.$.start.update();
				this.$.end.update();
				//this.set('collapsed', this.$.start.container == this.$.end.container && this.$.start.offset && this.$.end.container);
			},
			updateFromCurrentRange : function() {
				this.$.start.updateFromCurrentRange();
				this.$.end.updateFromCurrentRange();				
			},
			
			updateNativeRange : function() {
				var sc, ec, so, eo;
				
				sc = ec = this.$.start.container;
				so = eo = this.$.start.offset;

				if(!this.collapsed)
				{
					ec = this.$.end.container;
					eo = this.$.end.offset;
				}
				
				if(sc.hostMarker)
				{
					sc = sc.hostMarker.caretSpace;
					so = 0;
				}
				if(ec.hostMarker)
				{
					ec = ec.hostMarker.caretSpace;
					eo = 0;
				}
				utils.setCaretAt(sc, so, ec, eo);
			},
			
			adjust : function() {
				this.$.start.adjust();
				this.$.end.adjust();
			},
			ready : function() {
				this.isCaret = true;
				this._host = this;
				
				this.listeners = {};

				this.originalInnerHTML = '';
			},
			
			hide : function () {
				this.$.start.hide();
				this.$.end.hide();
			},
			
			keyUpHandler : function (e) {
				var keyCode = e.keyCode || e.which;

				if(!this.justUpdated)
				{
					this.hide();
					this.update();
				}
				if(this.preventNextDefault)
					e.preventDefault();

				this.preventNextDefault = this.justUpdated = false;
			},
			
			keyDownHandler : function (e) {
				var keyCode = e.keyCode, handled;
				
				if([16,17].indexOf(keyCode) > -1) // shift, ctrl, (alt)
					return e.preventDefault();

				"direction,enter,shiftEnter,delete".split(',').forEach(function(handler) {
					if(!handled)
						handled = this[handler + "KeyHandler"].call(this, e);
				}.bind(this));
			},
			
			enterKeyHandler : function(e) {
				var splitTop, cont, offset, nextPos, nextSplitTop, prevPos, prevSplitTop, state = {}, newp;
				
				if(e.keyCode != 13 || e.shiftKey)
					return;
					
				pos = this.startPosition;
				cont = pos.container;
				offset = pos.offset;
				
				if(utils.getTopCustomElementAncestor(cont, this.editor))
					return (e.shiftKey = true) && false;

				// determine where we are in container
				splitTop = utils.getNonCustomContainer(cont, this.editor);

				nextPos = this.caretNavigator.forward(pos.container, pos.offset);
				nextSplitTop = utils.getNonCustomContainer(nextPos.container, this.editor)
				prevPos = this.caretNavigator.backward(pos.container, pos.offset);
				prevSplitTop = utils.getNonCustomContainer(prevPos.container, this.editor)
			
				if(splitTop == this.editor)
					state.atEditor = true;
				else
				if(nextSplitTop != splitTop)
					state.atEnd = true;
				else
				if(prevSplitTop != splitTop)
					state.atStart = true;
				else
					state.atMiddle = true;
				
					
				// execute
				if(state.atEditor)
				{
					paste.pasteHtmlAtPos(newp = utils.newEmptyParagraph(), pos);
					paste.pasteHtmlAtPos(pos.container, { container : newp.firstChild, offset : 0 })
				}
				else
				if(state.atMiddle)
				{
					this.hide();
					utils.setCaretAt(this.startContainer, this.startOffset);
					splitTop = utils.splitNode(this.startContainer, this.startOffset, splitTop);
				}
				else
				if(state.atStart)
					paste.pasteHtmlAtPos(utils.newEmptyParagraph(), { container : splitTop, offset : 0 });
				else
				{
					paste.pasteHtmlAtPos(newp = utils.newEmptyParagraph(), 
											splitTop.nextSibling ? 
												{ container : splitTop.nextSibling, offset : 0 } : 
												{ container : splitTop.parentNode, offset : utils.getChildPositionInParent(splitTop) + 1 }
										);										
				}
				
				// update carets
				if(!newp)
				{
					this.setAt({ container : splitTop, offset : 0});
					this.go('forward');
				}
				else
					this.setAt({ container : newp.firstChild, offset : 0});
				
				e.preventDefault();
				this.preventNextDefault = true;
				this.justUpdated = true;

				return true;
			},
			
			shiftEnterKeyHandler : function(e) {
				var cont, offset, nextPos, lastPos, lastCont, twice, forward;
				
				if(e.keyCode != 13 || !e.shiftKey)
					return;

				cont = this.startPosition.container;
				offset = this.startPosition.offset;
				
				// double the br 
				twice = 
				forward =
					// when at end of textnode and there's no following br
					(utils.atText(this.startPosition, 'end') && !this.startContainer.nextSibling) ||
					// or when 
					(SYMBOLS.NCCONT(this.startContainer))
					
				forward = forward || this.$.start.visible || utils.atText(this.startPosition, 'end');
				
				this.hide();

				lastPos = paste.pasteHtmlAtPos("<br>", this.startPosition);
				lastCont = lastPos.container;
				
				this.setAt(lastPos);

				if(twice)
				{
					this.hide();
					paste.pasteHtmlAtPos("<br>", lastPos);
					this.setAt(lastPos);
				}
				
				e.preventDefault();
				this.preventNextDefault = true;
				this.justUpdated = true;
								
				return true;
			},
			
			deleteKeyHandler : function(e)
			{
				var pn, dir, 
					keyCode = e.keyCode || e.which, isTn, deleteCandidate, mergeCandidate,
					pos = this.startPosition, initialpos = pos, otherpos,
					poscont, otherposcont, targetPos, i, l;
				
				dir = keyCode == 8 && "backward"; // backspace
				dir = dir || (keyCode == 46) && "forward"; // del
				if(!dir)
					return false;

				// four outcomes:
				// 1a. default action - non-end of text in direction dir
				if(!this.$.start.visible && !utils.atText(pos, dir == "forward" ? "end" : "start"))
					return true;
				
				this.hide();

				if(dir == "forward")
				{
					pn = pos.container;
					if(pn.nodeType == 3)
						pn = pn.nextSibling;
				}
				else
					pn = pos.container.previousSibling;
				
				// 1b. default action - we are before an inline container
				if(SYMBOLS.INLINECONT(pn))
					return true;

				// 2. default action - caret before non-container block or custom element				
				if(utils.isInLightDom(pn, this.editor) && (SYMBOLS.NCBLOCK(pn) || SYMBOLS.IS(pn)))
				{
					if(dir == "forward")
					{
						poscont = pos.container;
						otherposcont = pn.nextSibling;
					}
					else
					{
						otherposcont = pos.container;
						poscont = pn.previousSibling;
					}
						
					utils.parentNode(pn, this.editor).removeChild(pn);
					
					// both remaining ends are text (think ---text---<br>---text---)
					if(SYMBOLS.TEXT(poscont) && SYMBOLS.TEXT(otherposcont) && poscont.nextSibling == otherposcont)
					{
						l = poscont.textContent.length;
						poscont.parentNode.normalize();
						pos = { container : poscont, offset : l };
					}
					else
					{
						pos = { container : otherposcont, offset : 0 };
					}
				}
				else
				{
					// 3. jump in dir and check against the other position
					this.go(dir);
					this.hide();
					
					// reminder:
					// pos is the original position
					// otherpos is the next position in dir direction
					
					otherpos = this.startPosition;
					
					// get closest non-custom container blocks for both positions
					poscont = pos.container;
					while(poscont != this.editor && !SYMBOLS.NCCONT(poscont) && poscont.parentNode != top)
						poscont = utils.parentNode(poscont);
					
					otherposcont = otherpos.container;
					while(otherposcont && otherposcont != this.editor && !SYMBOLS.NCCONT(otherposcont) && otherposcont.parentNode != top)
						otherposcont = utils.parentNode(otherposcont);

					// 3a. we are in the same container block - but actually this shouldn't be happening
					if(poscont != pos.container && poscont == otherposcont)
					{
						// landed in an inline container - default action
						if(SYMBOLS.INLINECONT(otherposcont))
							return true;
					}
					else
					// 3b we are in different neighbouring container blocks
					if(otherposcont && poscont[dir == "forward" ? "nextSibling" : "previousSibling"] == otherposcont)
					{
						// swap if needed
						if(dir == 'backward')
						{
							t = poscont;
							poscont = otherposcont;
							otherposcont = t;
						}
						
						// and merge
						utils.mergeNodes(poscont, poscont);
					}
					// else pull the sibling element unless it's a container or pos and otherpos are in different custom elements
					else
					{
						//otherposcont = poscont.previousSibling;
						//pos = this.startPosition; 							// pos is where we pull
						//poscont = pos.container;
						if(pos.container[dir == "forward" ? "nextSibling" : "previousSibling"] == otherposcont && !SYMBOLS.NCCONT(otherposcont) && 
							utils.getTopCustomElementAncestor(pos.container, this.editor) == utils.getTopCustomElementAncestor(otherposcont, this.editor))
						{
							otherpos.container.parentNode.insertBefore(pos.container, otherpos.container);
							if(otherpos.container.nodeType == 3 && pos.container.nodeType == 3)
							{
								otherposcont.parentNode.normalize();
								pos = { container : otherpos.container, offset : otherpos.container.textContent.length };
							}
						}
						else
							pos = this.startPosition;
					}
				}
				
				this.setAt(pos);
				this.justUpdated = true;
				this.preventNextDefault = true;
				e.preventDefault();
			},
			
			directionKeyHandler : function(e) {
				var dir, keyCode = e.keyCode, activeRangeSide, passiveRangeSide, ars, prs;
				
				dir = [36,37,33,38].indexOf(keyCode) > -1 && "backward"; 		 // home, left, pgUp, up
				dir = dir || [35,39,34,40].indexOf(keyCode) > -1 && "forward";  // end, right, pgDn, down
				
				if(!dir)
					return false;
				
				if(this.collapsed)
					this.lastActive = null;

				if(this.collapsed && !e.shiftKey)
					activeRangeSide = 'start';
				else
				if(!e.shiftKey || (e.shiftKey && !this.lastActive))
				{
					if(dir == "backward") 
						activeRangeSide = 'start';
					else
					if(dir == "forward")
						activeRangeSide = 'end';
						
					this.lastActive = activeRangeSide;
				}
				else
					activeRangeSide = this.lastActive || 'start';
					
				passiveRangeSide = activeRangeSide == "start" ? "end" : "start";
				
				if(dir && ([37,39].indexOf(keyCode) > -1))
				{
					ars = this.$[activeRangeSide];
					prs = this.$[passiveRangeSide];
					if(this.collapsed || e.shiftKey)
					{ // e.shiftKey ? activeRangeSide : "both", 
						ars.go(dir, { container : prs.realContainer, offset : prs.realOffset })
						if(!e.shiftKey)
							prs.setAt(ars.container, ars.offset);
						else
						if(!this.collapsed && prs == this.$.end && !prs.visible)
							prs.goAt({ container : prs.realContainer, offset : prs.realOffset})
						else
						if(this.collapsed && this.$.end.visible)
							this.$.end.goAt({container : ars.realContainer, offset : ars.realOffset});
					}
					else
						this.collapse(activeRangeSide == "end")
					
					this.updateNativeRange();
					
					this.justUpdated = true;
					
					e.preventDefault();
				}
				
				return true;
			},
			
			go : function(dir) {
				this.$.end.hide();
				this.$.start.go(dir);
				this.$.end.goAt(this.$.start);
				this.updateNativeRange();
			}
			
		});
	})();
</script>
