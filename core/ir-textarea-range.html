<dom-module id="ir-textarea-range">
	<template>
		<h1>caret debug</h1>
		collapsed: {{ collapsed }}
		<table on-click="log" style="marin-top : -400px" border=1 width="100%">
			<tr>
				<td></td>
				<td>tagOutline</td>
				<td>container</td>
				<td>offset</td>
				<td>visible</td>
			</tr>
			<tr>
				<td>Start</td>
				<td>{{ startTagOutline }}</td>
				<td>{{ startContainer }}</td>
				<td>{{ startOffset }}</td>
				<td>{{ startIsVisible }}</td>
			</tr>
			<tr>
				<td>End</td>
				<td>{{ endTagOutline }}</td>
				<td>{{ endContainer }}</td>
				<td>{{ endOffset }}</td>
				<td>{{ endIsVisible }}</td>
			</tr>
		</table>

		<ir-textarea-range-marker 
			id="start" 
			bind-to-range="start" 
			tag-outline="{{ startTagOutline }}" 
			real-container="{{ startContainer }}" 
			real-offset="{{ startOffset }}"
			visible="{{ startIsVisible }}"
		>
		</ir-textarea-range>
		<ir-textarea-range-marker 
			id="end" 
			bind-to-range="end" 
			tag-outline="{{ endTagOutline }}" 
			real-container="{{ endContainer }}" 
			real-offset="{{ endOffset }}"
			visible="{{ endIsVisible }}"
		>
		</ir-textarea-range>
	</template>
</dom-module>

<script>
	(function() {
		var utils = ir.textarea.utils,
			SYMBOLS = ir.textarea.CaretRulesets.Symbols,
			Rulesets = ir.textarea.CaretRulesets,
			paste = ir.textarea.paste;
		
		Polymer({
			is : "ir-textarea-range",
			properties : {
				editor : {
					type : Object,
					observer : "editorChanged"
				},
				collapsed : {
					type : String,
					notify : true,
					computed : "_collapsed(startContainer,startOffset,endContainer,endOffset)" 
				},
				startPosition : {
					type : Object,
					notify : true,
					computed : "_startPosition(startContainer,startOffset)" 
				},
				endPosition : {
					type : Object,
					notify : true,
					computed : "_endPosition(endContainer,endOffset)" 
				},
				startContainer : { type : Object, notify : true },
				startOffset : { type : Number, notify : true },
				endContainer : { type : Object, notify : true },
				endOffset : { type : Number, notify : true }
			},
			
			log : function(e) {
				console.log(this.startContainer, this.endContainer)
			},
			
			_startPosition : function(startContainer, startOffset) {
				return { container : startContainer, offset : startOffset }
			},
			_endPosition : function(endContainer, endOffset) {
				return { container : endContainer, offset : endOffset }
			},
			
			_collapsed : function(startContainer,startoffset,endContainer,endOffset)
			{
				return 	this.$.start.collapsed = 
						this.$.end.collapsed = 
						
						this.startContainer == this.endContainer && this.startOffset == this.endOffset;
			},
			
			collapse : function(toEnd) {
				var from, to;
				from = toEnd ? 'end' : 'start';
				to = toEnd ? 'start' : 'end';

				from = this.$[from];
				to = this.$[to];
				
				to.goAt({ container : from.realContainer, offset : from.realOffset });
				if(from == this.$.end)
					this.$.end.goAt({ container : from.realContainer, offset : from.realOffset });
				
				this.updateNativeRange();
			},
			
			editorChanged : function() {
				var caretNavOpts;
				
				this.$.start.editor = this.editor;
				this.$.end.editor = this.editor;

				this.editor.$.editor.addEventListener('keydown', this.keyDownHandler.bind(this));
				this.editor.$.editor.addEventListener('keyup', this.keyUpHandler.bind(this));
				
				this.editor.addEventListener('mousedown', function(e) { 
					if(!e.altKey) 
						return;
						
					var cp = utils.caretPositionFromPoint(e.clientX, e.clientY), t;
				
					t = utils.parentNode(cp.container)
					t.style.background = 'red';
					
					console.log(t);
					
					setTimeout(function() {
						t.style.background = "none";
					}, 300);
				});

				this.editor.$.editor.addEventListener('mousedown', this.mouseDownHandler.bind(this));
				//this.editor.addEventListener('mousemove', this.mouseUpHandler.bind(this));
				this.editor.$.editor.addEventListener('mouseup', this.mouseUpHandler.bind(this));
			
				Polymer.dom(this.editor.$.editor).observeNodes(function(info) {
					//this.processNewNodes(info.addedNodes);
					//this.processRemovedNodes(info.removedNodes);
				});	
				
				
				caretNavOpts = { 
						log : false, 
						caretSpan : this,
						caretSpanShow : false,
						caretSpanHide : false
					};

				this.caretNavigator = new ir.textarea.CaretNavigator(this.editor, caretNavOpts);
			},
			
			mouseUpHandler : function(e) {
				var hm, cp = utils.caretPositionFromPoint(e.clientX, e.clientY), startPos, endPos, reverseFlow, 
					lcpos = this.lastClick.pos, lccoords = this.lastClick.coords, target = e.target;
				
				if(Polymer.dom(target.firstChild).parentNode == this.editor)
					target = this.editor;
				
				if(!utils.isDescendantOf(target, this.editor, true))
					return;
				
				if((lcpos && lcpos.container == cp.container && lcpos.offset == cp.offset) ||
					 (lccoords && e.clientX == lccoords.x && e.clientY == lccoords.y))
				{
					this.lastActive = null;
				}
				else
				if(hm = cp.container.hostMarker || (utils.isContainer(cp.container) && (hm = cp.container.childNodes[cp.offset].hostMarker))) 
				{						
					cp.container = hm.caretSpace;
					cp.offset = 0;
					
					this.setAt(cp);

					console.log('mouseup:', cp);
				}
				else
				if(e.shiftKey || lcpos)
				{
					if(lcpos)
					{
						startPos = this.$.start;
						endPos = cp;
					}
					else
					{
						startPos = { container : this.startContainer, offset : this.startOffset };
						endPos = cp;
					}
					
					reverseFlow = utils.caretposcmp(startPos, endPos, this.editor) > 0;
					
					this.lastActive = reverseFlow ? 'end' : 'start'; 
					
					this.setAt(startPos, endPos);
				}

				//if(!this.justUpdated)
				this.updateFromCurrentRange();

				this.justUpdated = false;
	
				e.preventDefault();
			},
			
			mouseDownHandler : function(e) {
				var target = e.target, cp = utils.caretPositionFromPoint(e.clientX, e.clientY);

				if(Polymer.dom(target.firstChild).parentNode == this.editor)
					target = this.editor;
				
				if(!utils.isDescendantOf(target, this.editor, true))
					return;
					
				if(Polymer.dom(cp.container.firstChild).parentNode == this.editor)
					cp.container = this.editor;

				if(!this.lastClick.pos || !e.shiftKey)
				{
					this.lastClick.pos = { container : cp.container, offset : cp.offset }
					this.lastClick.coords = { x : e.clientX, y : e.clientY }
				}
				
				this.justUpdated = true;
				
				if(!e.shiftKey)
					this.setAt(cp);
			},
			
			
			// can be called as:
			// 			setAt({ startPosition : pos, endPosition : pos})
			//		or 	setAt(startPos, endPos)
			//		or	setAt(startContainer, startOffset, endContainer, endOffset)
			setAt : function(startContainer, startOffset, endContainer, endOffset) {
				//if(startContaienr == endContainer && startOffset == endOffset)
				var startPos, endPos, t, reverseFlow;
				
				if(startContainer.startPosition)
				{
					startOffset = startContainer.endPosition
					startContainer = startContainer.startPosition
				}
				
				if(startContainer.container)
				{
					startPos = startContainer;
					endPos = startOffset;
				}
				else
				{
					startPos = { container : startContainer, offset : startOffset };
					endPos = { container : endContainer, offset : endOffset };
				}
					
				if(!endPos || !endPos.container)
					endPos = startPos;
				else
				// swap if reverse flow order
				if(utils.caretposcmp(startPos, endPos, this.editor) > 0)
				{
					t = startPos;
					if(t.hostMarker)
						t = { container : t.hostMarker.realContainer, offset : t.hostMarker.realOffset };

					startPos = endPos;
					endPos = t;
				}
								
				if(!(this.$.start.visible && this.$.start.isAt(startPos)))
					this.$.start.goAt(startPos);
				
				if(startPos == endPos)
					this.$.end.setAt(this.$.start)
				else
				if(!(this.$.end.visible && this.$.end.isAt(endPos)))
					this.$.end.goAt(endPos)
		
				this.updateNativeRange()
				//if(this.collapsed)
				//	this.$.end.hide();
			},
			
			setStartAt : function(c, o) {
				this.$.start.goAt(c, o);
			},
			setEndAt : function(c, o) {
				this.$.end.goAt(c, o);
			},
			update : function() {
				this.$.start.update();
				this.$.end.update();
				//this.set('collapsed', this.$.start.container == this.$.end.container && this.$.start.offset && this.$.end.container);
			},
			updateFromCurrentRange : function() {
				this.$.start.updateFromCurrentRange();
				this.$.end.updateFromCurrentRange();				
			},
			
			updateNativeRange : function() {
				var sc, ec, so, eo;
				
				sc = ec = this.$.start.container;
				so = eo = this.$.start.offset;

				if(!this.collapsed)
				{
					ec = this.$.end.container;
					eo = this.$.end.offset;
				}
				
				if(sc.hostMarker)
				{
					sc = sc.hostMarker.caretSpace;
					so = 0;
				}
				if(ec.hostMarker)
				{
					ec = ec.hostMarker.caretSpace;
					eo = 0;
				}
				utils.setCaretAt(sc, so, ec, eo);
			},
			
			adjust : function() {
				this.$.start.adjust();
				this.$.end.adjust();
			},
			ready : function() {
				this.isCaret = true;
				this._host = this;
				
				this.listeners = {};

				this.originalInnerHTML = '';

				this.lastClick = {};
				
				this.posStack = [];	
			},
			
			hide : function () {
				this.$.start.hide();
				this.$.end.hide();
			},
			
			show : function () {
				this.$.start.show();
				this.$.end.show();
			},

			keyUpHandler : function (e) {
				var keyCode = e.keyCode || e.which, ars, prs, ap, pp, noupdate, atmidtext;

				if([16,17].indexOf(keyCode) > -1) // shift, ctrl, (alt)
					return e.preventDefault();
					
				this._hold = false;
				
				Polymer.dom.flush();
				
				if(!this.justUpdated)
				{
					this.hide();
					this.update();
				}
				if(this.preventNextDefault)
					e.preventDefault();
				
				if(this.lastActive)
				{
					ars = this.$[this.lastActive];
					prs = this.$[this.lastActive == "start" ? "end" : "start"];
					
					ap = ars.posPop();
					pp = prs.posPop();
					
					if(ap && e.shiftKey && (keyCode == 38 || keyCode == 40))
					{
						atmidtext = utils.atText(ars.realPosition, 'middle')
						if(keyCode == 38 && !atmidtext)
							ars.go('backward');
						else
						if(keyCode == 40 && !atmidtext)
							ars.go('forward');

						prs.goAt(pp);
					
						noupdate = true;
					}
				}

				if(this.collapsed)
					this.lastActive = null;
				
				this.updateFromCurrentRange();				
				
				this.preventNextDefault = this.justUpdated = false;
			},
			
			keyDownHandler : function (e) {
				var keyCode = e.keyCode, handled;
				
				if([16,17].indexOf(keyCode) > -1) // shift, ctrl, (alt)
				{	
					this._hold = false;
					return e.preventDefault();
				}
					
				if(this._hold)
					this.keyUpHandler(e);
	
				this._hold = true;
				
				"expandedRangeValue,selectAll,copy,cut,direction,enter,shiftEnter,delete".split(',').forEach(function(handler) {
					if(!handled)
						handled = this[handler + "KeyHandler"].call(this, e);
				}.bind(this));
			},
			
			posPush : function() {
				this.$.start.posPush();
				this.$.end.posPush();
			},
			
			posPop : function() {
				this.$.start.goAt(this.$.start.posPop());
				this.$.end.goAt(this.$.end.posPop());
			},

			// removes range contents when range is not collapsed and no control key is pressed
			// stores the last extracted value in this.lastExtracted
			expandedRangeValueKeyHandler : function(e) {
				var key = e.keyCode, parking;

				if(this.collapsed ||
						[36,37,33,34,38,35,39,34,40 /* direction keys */].indexOf(key) > -1 ||
						[18,20,27,93,96,144  /* tab,capslock,esc,contextmenu(windows?),ins,numlock */].indexOf(key) > -1 ||
						
						(key >= 112 && key <= 123) || // F1-F12
						
						e.shiftKey || e.ctrlKey || e.altKey
					)
					return false;

				parking = this.caretNavigator.backward(this.startContainer, this.startOffset);
				//this.posPush();
				this.hide();
				this.lastExtracted = ir.textarea.extract.extractContents(this.$.start, this.$.end, { top : this.editor, delete : true });
				
				this.setAt(this.caretNavigator.forward(parking.container, parking.offset));
			
				if(e.keyCode == 8 || e.keyCode == 46)
				{
					e.preventDefault();
					this.preventNextDefault = this.justUpdated = true;
					return true;
				}
			},
			
			copy : function() {
				var s, e;
				
				this.hide();
				console.log('copy')
				
				s = this.$.start;
				e = this.$.end;
				
				extract = ir.textarea.extract.extractContents(this.$.start, this.$.end);

				if(extract.nodeType == 3)
					console.log(extract);
				else
					console.log(Polymer.dom(extract).innerHTML);

				this.setAt(s, e);
			},
			
			cut : function() {
				var s, e;
				
				console.log('cut')

				this.hide();

				s = utils.clonePos(this.$.start);
				e = utils.clonePos(this.$.end);

				this.go('backward'); // it's safer to go backward because positions and elements won't change as much there
				this.posPush();
				
				this.hide();
				
				extract = ir.textarea.extract.extractContents(s, e, { delete : true });
				
				if(Polymer.dom(this.editor).childNodes.length)
				{
					this.posPop();
					this.go('forward');
				}
				else
					this.setAt(this.editor, 0)
				
				if(extract.nodeType == 3)
					console.log(extract);
				else
					console.log(Polymer.dom(extract).innerHTML);
				
				return true;
			},

			cutKeyHandler : function(e) {
				if(e.keyCode == 88 && e.ctrlKey)
				{
					this.cut();
				
					this.justUpdated = true;
					
					e.preventDefault();
					this.preventNextDefault = true;
					
					return true;
				}
			},
			
			copyKeyHandler : function(e) {
				if(e.keyCode == 67 && e.ctrlKey)
				{
					this.copy();

					e.preventDefault();
					this.preventNextDefault = true;
					
					return true;
				}
			},
			
			selectAllKeyHandler : function(e) {
				if(e.keyCode != 65 || !e.ctrlKey)
					return;

				this.setAt({ container : this.editor, offset : 0 }, { container : this.editor, offset : Polymer.dom(this.editor).childNodes.length})
			
				e.preventDefault();
				
				return true;
			},

			enterKeyHandler : function(e) {
				var cont, hasContentBefore, hasContentAfter, right, ped, pos;

				if(e.keyCode != 13 || e.shiftKey)
					return;

				this.hide();


				ped = Polymer.dom(this.startContainer).parentNode;  //Polymer.dom(this.editor);
				
				cont = utils.getNonCustomContainer(this.startPosition.container, this.editor, true);
				pcont = Polymer.dom(utils.parentNode(cont));
				
				
				hasContentBefore = utils.posToContainerEdgeHasContent(this.startPosition, "backward", this.editor);
				hasContentAfter = utils.posToContainerEdgeHasContent(this.startPosition, "forward", this.editor);

				if(utils.parentNode(this.startContainer) == this.editor)
				{
					// if it's a bare node it feels more consistent to wrap and then split
					ir.textarea.wrap.wrapRangeBlockLevel(this, "span class='paragraph'", null, this.editor)
					this.setAt({ container : this.startContainer, offset : this.startOffset });
					
					cont = utils.getNonCustomContainer(this.startPosition.container, this.editor, true);
					hasContentBefore = utils.posToContainerEdgeHasContent(this.startPosition, "backward", this.editor);
					hasContentAfter = utils.posToContainerEdgeHasContent(this.startPosition, "forward", this.editor);
				}

				if(hasContentBefore && hasContentAfter)
				{
					right = ir.textarea.extract.splitNode(this.startContainer, this.startOffset, cont, this.editor);
				}
				else
				if(!hasContentBefore)
				{
					pcont.insertBefore(right = Polymer.dom(cont).cloneNode(), cont);
					Polymer.dom(right).appendChild(utils.createTag('br'));
					right = null;
				}
				else
				{
					pcont[pcont.lastChild == cont ? "appendChild" : "insertBefore"](right = Polymer.dom(cont).cloneNode(), Polymer.dom(cont).nextSibling);
					Polymer.dom(right).appendChild(utils.createTag('br'));
					Polymer.dom.flush();
				}
				
				if(right)
					this.setAt(this.caretNavigator.forward(right, 0 ))
				else
					this.setAt(this.startPosition);
				
				e.preventDefault();
				this.preventNextDefault = true;
				this.justUpdated = true;
 			},
			
			shiftEnterKeyHandler : function(e) {
				var dir, keyCode = e.keyCode || e.which, br, pos;
				
				if(keyCode != 13 || !e.shiftKey)
					return false;

				this.hide();
					
				if(utils.atText(this.startPosition, 'end') && !this.startContainer.nextSibling)
					paste.pasteHtmlAtPos(utils.createTag('br'), this.startPosition);
				
				pos = paste.pasteHtmlAtPos(br = utils.createTag('br'), this.startPosition);
				this.setAt(pos);
			
				e.preventDefault();
				
				return this.preventNextDefault = this.justUpdated = true;
			},
			
			setAfter : function(el, dir) {
				if(el.nodeType == 3 && dir != "backward")
					return this.setAt(el, el.textContent.length);
			
				this.setAt(el, 0);
				if(dir != "backward" && el != this.editor)
					this.go("forward");
			},
			
			setBefore : function(el, dir) {
				if(el.nodeType == 3 && dir == "backward")
					return this.setAt(el, el.textContent.length);

				this.setAt(el, 0);
				if(dir == 'backward')
					this.go('forward');
			},


			deleteKeyHandler : function(e) {
				var cont, hasContentBefore, hasContentAfter, right, ped, dir, otherdir, atText,
					keyCode = e.keyCode || e.which, tcea,
					next, thisCont, nextCont, p, n, pos, hc,

					nextInDir = function(n) { return Polymer.dom(n)[dir == "forward" ? "nextSibling" : "previousSibling"] },
					nextInDirOrParent = function(n) { return nextInDir(n) || Polymer.dom(n).parentNode; },
					prevInDir = function(n) { return Polymer.dom(n)[dir == "forward" ? "previousSibling" : "nextSibling"] },
					prevInDirOrParent = function(n) { return prevInDir(n) || Polymer.dom(n).parentNode },
					nextNodeInDir = function(n) { return dir == "forward" ? utils.nextNode(n, top, true) : utils.prevNode(n, top) },
					mergeInDir = function(n1, n2) { return dir == "forward" ? utils.mergeNodes(n1, n2) : utils.mergeNodes(n2, n1); };
				
				dir = keyCode == 8 && "backward"; // backspace
				dir = dir || (keyCode == 46) && "forward"; // del
				if(!dir)
					return false;

				otherdir = dir == "forward" ? "backward" : "forward";
					
				this.hide();

				cont = utils.getNonCustomContainer(this.startPosition.container, this.editor, true);
				tcea = utils.getTopCustomElementAncestor(this.startContainer, this.editor, true)
				ped = Polymer.dom(this.editor);

				hasContentBefore = utils.posToContainerEdgeHasContent(this.startPosition, "backward", this.editor, true);
				hasContentAfter = utils.posToContainerEdgeHasContent(this.startPosition, "forward", this.editor, true);
				
				this.posPush();
				this.hide();
				
				if(!hasContentBefore && !hasContentAfter && !tcea)
				{
					pos = this.caretNavigator[dir](this.startPosition);
					
					if(cont)
						utils.removeFromParent(cont);
					
					this.setAt(pos);
					
					e.preventDefault();
					return this.preventNextDefault = this.justChanged = true;
				}
				

				atText = utils.atText(this.startPosition);

				// default action
				if(atText == "middle" || ((dir == 'forward' && atText == 'start') || (dir == 'backward' && atText == 'end')))
				{
					if(this.startPosition.container.textContent.length > 1)
						return true;
					else
					// one big case when deleting the last character
					// since the text container is deleted
					{
						n = this.startPosition.container;
						pos = this.caretNavigator[otherdir](this.startPosition);

						p = utils.parentNode(n);
						utils.removeFromParent(n);

						while(p != cont && p != top && !(hc = utils.nodeHasContent(p)) && !utils.isNonCustomContainer(p))
						{
							n = p;
							p = utils.parentNode(n);
							while(utils.isLayoutElement(p))
							{
								p = utils.parentNode(p);
								hc = utils.nodeHasContent(p)
							}
							if(!hc)
								utils.removeFromParent(n);
						}
						
						if(cont && utils.isNonCustomContainer(cont) && !Polymer.dom(cont).childNodes.length)
						{
							Polymer.dom(cont).appendChild(n = utils.createTag('br'))
							pos = { container : n, offset : 0 }
						}
						else
							pos = this.caretNavigator[dir](pos);
						
						this.setAt(pos);

						e.preventDefault();
						return this.preventNextDefault = this.justChanged = true;
					}
				}
				
				// elements that dont get deleted: caption, table cell
				if((tcea || utils.isTag(cont, 'TD') && ((dir == 'backward' && !hasContentBefore) || (dir == 'forward' && !hasContentAfter))))
				{
					e.preventDefault();
					return this.preventNextDefault = this.justChanged = true;
				}
			
				// if deleting backward, always look at previous element
				if(dir == 'backward' || atText)
					next = nextInDir(this.startPosition.container);
				// if deleting forwrad, we need to step forward only when at end of a text node,
				// otherwise we already are at the container we want to delete
				else
					next = this.startPosition.container;
				
				// if it's last br deleting forward, remove the br. experimental
				if(dir == "forward" && utils.isTag(next, 'BR') && next == Polymer.dom(utils.parentNode(next)).lastChild)
				{
					utils.removeFromParent(next);
					next = Polymer.dom(utils.parentNode(next)).lastChild;
				}
								
				// remove atomic block / custom element in direction, except <br> when it's the last/first position
				if(next && (!utils.canHaveChildren(next) || next.is || !utils.nodeHasContent(next)))
				{
					utils.removeFromParent(next);

					this.setAt(utils.maybeMergeTextNeighbours(this.startPosition));

					if(dir == "backward")
						this.setAt(this.startPosition);
					else
						this.posPop();
						
				}
				// two containers - merge
				else
				{
					next = nextInDir(cont);
					if(next)
						this.setAt(mergeInDir(cont, next));
				}
				
				e.preventDefault();
				this.preventNextDefault = true;
				this.justUpdated = true;
			},
			
			directionKeyHandler : function(e) {
				var dir, keyCode = e.keyCode, activeRangeSide, passiveRangeSide, ars, prs, prevPos;
				
				dir = [36,37,33,38].indexOf(keyCode) > -1 && "backward"; 		 // home, left, pgUp, up
				dir = dir || [35,39,34,40].indexOf(keyCode) > -1 && "forward";  // end, right, pgDn, down
				
				this.hide();
				
				if(!dir)
					return false;
				
				if(!e.shiftKey)
					activeRangeSide = 'start';
				else
				if(e.shiftKey && !this.lastActive)
				{
					if(dir == "backward") 
						activeRangeSide = 'start';
					else
					if(dir == "forward")
						activeRangeSide = 'end';
						
					this.lastActive = activeRangeSide;
				}
				else
					activeRangeSide = this.lastActive || 'start';
					
				passiveRangeSide = activeRangeSide == "start" ? "end" : "start";
				
				ars = this.$[activeRangeSide];
				prs = this.$[passiveRangeSide];

				//this.hide();
				
				if(dir && ([37,39].indexOf(keyCode) > -1))
				{
					if(this.collapsed || e.shiftKey)
					{ // e.shiftKey ? activeRangeSide : "both", 
						ars.go(dir, this.$.start)
						if(!e.shiftKey)
							prs.setAt(ars.container, ars.offset);
						else
						if(!this.collapsed && prs == this.$.end && !prs.visible)
							prs.goAt({ container : prs.realContainer, offset : prs.realOffset})
						else
						if(this.collapsed && this.$.end.visible)
							this.$.end.goAt({container : ars.realContainer, offset : ars.realOffset});
					}
					else
						this.collapse(dir == "forward")
					
					this.updateNativeRange();
					
					this.justUpdated = true;
					this.preventNextDefault = true;
				
					e.preventDefault();
				}
				else
				{
					//this.hide();
					prs.posPush();
					ars.posPush();
					this.justUpdated = true;
				}
				return true;
			},
			
			go : function(dir) {
				this.$.end.hide();
				this.$.start.go(dir);
				this.$.end.goAt(this.$.start);
				this.updateNativeRange();
			},
			
			execCommand : function(aCommandName, aShowDefaultUI, aValueArgument) {
				this.hide();
				var p = ir.textarea.execCommand(this, aCommandName, aShowDefaultUI, aValueArgument, this.editor);
				this.setAt(p);
				return p;
			}
			
		});
	})();
</script>
