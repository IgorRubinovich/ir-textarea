<dom-module id="ir-textarea-range">
	<template>
		<h1>caret debug</h1>
		collapsed: {{ collapsed }}
		<table on-click="log" style="marin-top : -400px" border=1 width="100%">
			<tr>
				<td></td>
				<td>tagOutline</td>
				<td>container</td>
				<td>offset</td>
				<td>visible</td>
			</tr>
			<tr>
				<td>Start</td>
				<td>{{ startTagOutline }}</td>
				<td>{{ startContainer }}</td>
				<td>{{ startOffset }}</td>
				<td>{{ startIsVisible }}</td>
			</tr>
			<tr>
				<td>End</td>
				<td>{{ endTagOutline }}</td>
				<td>{{ endContainer }}</td>
				<td>{{ endOffset }}</td>
				<td>{{ endIsVisible }}</td>
			</tr>
		</table>

		<ir-textarea-range-marker 
			id="start" 
			bind-to-range="start" 
			tag-outline="{{ startTagOutline }}" 
			real-container="{{ startContainer }}" 
			real-offset="{{ startOffset }}"
			visible="{{ startIsVisible }}"
		>
		</ir-textarea-range>
		<ir-textarea-range-marker 
			id="end" 
			bind-to-range="end" 
			tag-outline="{{ endTagOutline }}" 
			real-container="{{ endContainer }}" 
			real-offset="{{ endOffset }}"
			visible="{{ endIsVisible }}"
		>
		</ir-textarea-range>
	</template>
</dom-module>

<script>
	(function() {
		var utils = ir.textarea.utils;

		Polymer({
			is : "ir-textarea-range",
			properties : {
				editor : {
					type : Object,
					observer : "editorChanged"
				},
				collapsed : {
					type : String,
					notify : true,
					computed : "_collapsed(startContainer,startOffset,endContainer,endOffset)" 
				},
				startContainer : { type : Object, notify : true },
				startOffset : { type : Number, notify : true },
				endContainer : { type : Object, notify : true },
				endOffet : { type : Number, notify : true }
			},
			
			log : function(e) {
				console.log(this.startContainer, this.endContainer)
			},
			
			_collapsed : function(startContainer,startoffset,endContainer,endOffset)
			{
				//this.set("collapsed", );
				//console.log(this.startContainer == this.endContainer && this.startOffset == this.endOffset)
				return this.startContainer == this.endContainer && this.startOffset == this.endOffset
			},
			
			collapse : function(toEnd) {
				var from, to;
				from = toEnd ? 'end' : 'start';
				to = toEnd ? 'start' : 'end';

				from = this.$[from];
				to = this.$[to];
				
				to.goAt({ container : from.realContainer, offset : from.realOffset });
				if(from == this.$.end)
					this.$.end.goAt({ container : from.realContainer, offset : from.realOffset });
				
				this.updateNativeRange();
			},
			
			editorChanged : function() {
				this.$.start.editor = this.editor;
				this.$.end.editor = this.editor;

				this.editor.addEventListener('keydown', this.keyDownHandler.bind(this));
				this.editor.addEventListener('keyup', this.keyUpHandler.bind(this));
				
				this.editor.addEventListener('mousedown', this.mouseDownHandler.bind(this));
				this.editor.addEventListener('mouseup', this.mouseUpHandler.bind(this));
			},
			
			mouseUpHandler : function(e) {
				var cp = utils.caretPositionFromPoint(e.clientX, e.clientY), startPos, endPos, reverseFlow;
				if(e.shiftKey && this.lastClickPos)
				{
					startPos = { container : this.lastClickPos.container, offset : this.lastClickPos.offset };
					endPos = { container : cp.container, offset : cp.offset };
					
					reverseFlow = utils.caretposcmp(startPos, endPos, this.editor) > 0;
					
					this.lastActive = reverseFlow ? 'end' : 'start'; 
					
					this.setAt(startPos, endPos);
					
					this.justUpdated = true;
				}
				else
				{
					this.update();
					this.lastClickPos = null;
				}
			},
			
			mouseDownHandler : function(e) {
				cp = utils.caretPositionFromPoint(e.clientX, e.clientY);
				if(!e.shiftKey)
				{
					this.lastClickPos = { container : cp.container, offset : cp.offset }
					this.setAt(cp.container, cp.offset);
				}
			},
			
			setAt : function(startContainer, startOffset, endContainer, endOffset) {
				//if(startContaienr == endContainer && startOffset == endOffset)
				var startPos, endPos, t;
				
				if(startContainer.container)
				{
					startPos = startContainer;
					endPos = startOffset;
				}
				else
				{
					startPos = { container : startContainer, offset : startOffset };
					endPos = { container : endContainer, offset : endOffset };
				}
					
				if(!endPos || !endPos.container)
					endPos = startPos;
					
				// swap if reverse flow order
				if(utils.caretposcmp(startPos, endPos, this.editor) > 0)
				{
					t = startPos;
					startPos = endPos;
					endPos = t;
				}
				
				this.$.start.hide();
				
				this.$.end.goAt(endPos);
				this.$.start.goAt(startPos);				
				
				if(this.collapsed)
					this.$.end.hide();
			},
			
			setStartAt : function(c, o) {
				this.$.start.goAt(c, o);
			},
			setEndAt : function(c, o) {
				this.$.end.goAt(c, o);
			},
			update : function() {
				this.$.start.update();
				this.$.end.update();
				//this.set('collapsed', this.$.start.container == this.$.end.container && this.$.start.offset && this.$.end.container);
			},
			updateFromCurrentRange : function() {
				this.$.start.updateFromCurrentRange();
				this.$.end.updateFromCurrentRange();				
			},
			
			updateNativeRange : function() {
				utils.setCaretAt(this.$.start.container, this.$.start.offset, this.$.end.container, this.$.end.offset);
			},
			
			adjust : function() {
				this.$.start.adjust();
				this.$.end.adjust();
			},
			ready : function() {
				this.isCaret = true;
				this._host = this;
				
				this.listeners = {};

				this.originalInnerHTML = '';
			},
			
			keyUpHandler : function (e) {
				var keyCode = e.keyCode || e.which;

				if(!this.justUpdated)
					this.update();
				
				this.justUpdated = false;
				
				return e.preventDefault();			
			},
			
			keyDownHandler : function (e) {
				var dir, keyCode = e.keyCode, activeRangeSide, passiveRangeSide, ars, dir;
				
				if([16,17].indexOf(keyCode) > -1) // shift, ctrl, (alt)
					return e.preventDefault();
				
				dir = [36,37,33,38].indexOf(keyCode) > -1 && "backward"; 		 // home, left, pgUp, up
				dir = dir || [35,39,34,40].indexOf(keyCode) > -1 && "forward";  // end, right, pgDn, down
				
				if(this.collapsed)
					this.lastActive = null;

				if(this.collapsed && !e.shiftKey)
					activeRangeSide = 'start';
				else
				if(!e.shiftKey || (e.shiftKey && !this.lastActive))
				{
					if(dir == "backward") 
						activeRangeSide = 'start';
					else
					if(dir == "forward")
						activeRangeSide = 'end';
						
					this.lastActive = activeRangeSide;
				}
				else
					activeRangeSide = this.lastActive || 'start';
					
				passiveRangeSide = activeRangeSide == "start" ? "end" : "start";
				
				if(dir && ([37,39].indexOf(keyCode) > -1))
				{
					ars = this.$[activeRangeSide];
					prs = this.$[passiveRangeSide];
					if(this.collapsed || e.shiftKey)
					{ // e.shiftKey ? activeRangeSide : "both", 
						ars.go(dir, { container : prs.realContainer, offset : prs.realOffset })
						if(!e.shiftKey)
							prs.setAt(ars.container, ars.offset);
						else
						if(!this.collapsed && prs == this.$.end && !prs.visible)
							prs.goAt({ container : prs.realContainer, offset : prs.realOffset})
						else
						if(this.collapsed && this.$.end.visible)
							this.$.end.goAt({container : ars.realContainer, offset : ars.realOffset});
					}
					else
						this.collapse(activeRangeSide == "end")
					
					this.updateNativeRange();
					
					this.justUpdated = true;
					
					e.preventDefault();
				}
			},
			
			switchMarker : function(shiftKey) {
				this.shiftKey = shiftKey;
				this.activeMarker = !shiftKey ? "start" : "end";
				this.inactiveMarker = shiftKey ? "start" : "end";
			}
		});
	})();
</script>
